--- src/components/screens/ResultScreen.tsx ---
// src/components/screens/ResultScreen.tsx
import React from "react";
import { RotateCcw, Home } from "lucide-react";
import { cn } from "@/lib/utils";
import { GameState, UIMode } from "@/types";

interface ResultScreenProps {
  gameState: GameState;
  uiMode: UIMode;
  onRetry: () => void;
  onHome: () => void;
}

export const ResultScreen: React.FC<ResultScreenProps> = ({
  gameState,
  uiMode,
  onRetry,
  onHome,
}) => {
  const isRugged = uiMode === "RUGGED";

  const containerStyle = isRugged
    ? "bg-white text-black font-mono selection:bg-black selection:text-white"
    : "bg-gradient-to-br from-indigo-900 via-purple-900 to-black text-white font-sans";

  const buttonStyle = isRugged
    ? "border-2 border-black px-4 py-2 hover:bg-black hover:text-white transition-colors uppercase font-bold text-sm"
    : "bg-white/20 hover:bg-white/30 px-6 py-3 rounded-full font-bold backdrop-blur text-sm transition-transform active:scale-95";

  return (
    <div
      className={cn(
        "min-h-screen flex flex-col items-center justify-center p-8 text-center",
        containerStyle
      )}
    >
      <div className="animate-in slide-in-from-bottom-10 fade-in duration-500 space-y-8 w-full max-w-sm">
        <div className="space-y-2">
          <h2 className="text-xl font-bold opacity-60">FINISHED</h2>
          <div className="text-8xl font-black tracking-tighter">
            {gameState.score}
          </div>
        </div>

        <div
          className={cn(
            "p-6 w-full mx-auto space-y-3",
            isRugged ? "bg-gray-100" : "bg-white/10 rounded-xl"
          )}
        >
          <div className="flex justify-between text-sm font-bold">
            <span className="opacity-60">DIFFICULTY</span>
            <span>{gameState.difficulty}</span>
          </div>
          <div className="flex justify-between text-sm font-bold">
            <span className="opacity-60">MAX COMBO</span>
            <span className="text-yellow-500">{gameState.maxCombo}</span>
          </div>
          <div className="h-px bg-current opacity-20" />
          <div className="flex justify-between text-sm font-bold">
            <span className="opacity-60">HIGH SCORE</span>
            <span>{Math.max(gameState.score, gameState.highScore)}</span>
          </div>
        </div>

        <div className="flex gap-4 justify-center pt-8">
          <button onClick={onHome} className={buttonStyle}>
            <Home size={20} />
          </button>
          <button
            onClick={onRetry}
            className={cn(buttonStyle, "flex items-center gap-2")}
          >
            <RotateCcw size={20} /> RETRY
          </button>
        </div>
      </div>
    </div>
  );
};
--- src/components/screens/GameScreen.tsx ---
// src/components/screens/GameScreen.tsx
import React, { useState, useEffect } from "react";
import { Home } from "lucide-react";
import { cn } from "@/lib/utils";
import { GameConfig, GameState, FeedbackState, AnswerType } from "@/types";
import { Keypad } from "@/components/ui/Keypad";
import { NumberPanel } from "@/components/ui/NumberPanel";
import { ProgressionLane } from "@/components/ui/ProgressionLane"; // ★ 新規追加
import { useSound } from "@/hooks/useSound";

interface GameScreenProps {
  config: GameConfig;
  gameState: GameState;
  feedback: FeedbackState | null;
  onAnswer: (val: AnswerType) => void;
  onAbort: () => void;
  onStartGame: () => void;
}

export const GameScreen: React.FC<GameScreenProps> = ({
  config,
  gameState,
  feedback,
  onAnswer,
  onAbort,
  onStartGame,
}) => {
  const isRugged = config.uiMode === "RUGGED";
  const { playRankSound, playPass, playCount, playGo } = useSound(
    config.isSoundEnabled
  );

  // カウントダウン
  const [count, setCount] = useState(3);
  useEffect(() => {
    if (gameState.status === "COUNTDOWN") {
      setCount(3);
      playCount?.();
      const timer = setInterval(() => setCount((prev) => prev - 1), 1000);
      return () => clearInterval(timer);
    }
  }, [gameState.status, playCount]);

  useEffect(() => {
    if (gameState.status !== "COUNTDOWN") return;
    if (count > 0 && count < 3) playCount?.();
    if (count === 0) {
      playGo?.();
      onStartGame();
    }
  }, [count, gameState.status, playCount, playGo, onStartGame]);

  // 効果音 (ランク対応)
  useEffect(() => {
    if (feedback?.type === "CORRECT" && feedback.rank) {
      playRankSound?.(feedback.rank);
    } else if (feedback?.type === "CORRECT") {
      playRankSound?.("GOOD"); // fallback
    } else if (feedback?.type === "MISS" || feedback?.type === "TIME_UP") {
      playPass?.();
    }
  }, [feedback, playRankSound, playPass]);

  const containerStyle = isRugged
    ? "bg-white text-black font-mono"
    : "bg-gradient-to-br from-slate-900 via-blue-950 to-black text-white font-sans";

  const showTutorial =
    gameState.difficulty === "STARTER" && gameState.questionCount === 1;

  return (
    <div
      className={cn(
        "min-h-screen flex flex-col items-center relative overflow-hidden",
        containerStyle
      )}
    >
      {/* カウントダウンオーバーレイ */}
      {gameState.status === "COUNTDOWN" && (
        <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
          <div className="text-9xl font-black text-white animate-bounce">
            {count > 0 ? count : "GO!"}
          </div>
        </div>
      )}

      {/* Header: Score & Gauge */}
      <div className="w-full max-w-md pt-8 px-4 pb-4 space-y-4 z-10">
        <div className="flex justify-between items-end px-2">
          <div className="text-sm font-bold opacity-60">SCORE</div>
          <div className="text-4xl font-black tabular-nums leading-none">
            {gameState.score}
          </div>
        </div>

        {/* Clear Gauge */}
        <div className="relative w-full h-6 bg-gray-700 rounded-full overflow-hidden border-2 border-gray-600">
          <div
            className={cn(
              "h-full transition-all duration-300 ease-out",
              gameState.clearGauge > 50
                ? "bg-green-500"
                : gameState.clearGauge > 20
                ? "bg-yellow-500"
                : "bg-red-500"
            )}
            style={{ width: `${gameState.clearGauge}%` }}
          />
          <div className="absolute inset-0 flex items-center justify-center text-xs font-bold text-white shadow-black drop-shadow-md">
            LIFE
          </div>
        </div>

        {/* Combo */}
        <div className="h-8 flex justify-center">
          {gameState.combo > 1 && (
            <div className="text-yellow-400 font-black italic text-xl animate-pulse">
              {gameState.combo} COMBO!
            </div>
          )}
        </div>
      </div>

      {/* Main Game Area */}
      <div className="w-full max-w-md flex-1 flex flex-col items-center justify-center relative z-10 px-4">
        <NumberPanel
          formula={gameState.currentFormula}
          value={gameState.displayValue}
          status={gameState.status}
          uiMode={config.uiMode}
        />

        {/* STARTER用 チュートリアル */}
        {showTutorial && gameState.status === "FLASH" && (
          <div className="absolute top-0 -mt-12 text-yellow-400 font-bold text-lg animate-bounce drop-shadow-md whitespace-nowrap">
            Remember the answer!
          </div>
        )}
        {showTutorial && gameState.status === "INPUT" && (
          <div className="absolute top-0 -mt-12 text-cyan-400 font-bold text-lg animate-pulse drop-shadow-md text-center">
            Is this Number
            <br />
            HIGH or LOW?
          </div>
        )}

        {/* ★ Feedback Overlay (Luxury Mode: Rank Effect) */}
        {feedback && (
          <div className="absolute inset-0 flex items-center justify-center z-20 pointer-events-none">
            {/* Rugged Mode / Miss / TimeUp */}
            {isRugged || feedback.type !== "CORRECT" ? (
              <span
                className={cn(
                  "text-6xl font-black animate-ping-once opacity-0 transform scale-50",
                  feedback.type === "CORRECT"
                    ? "text-green-500"
                    : "text-red-500"
                )}
              >
                {feedback.msg}
              </span>
            ) : (
              // ★ Luxury Mode: 正解時のランク演出
              <div className="flex flex-col items-center">
                {/* ランク文字 */}
                <div
                  className={cn(
                    "text-6xl sm:text-7xl font-black italic tracking-tighter animate-ping-once opacity-0 transform scale-50 drop-shadow-[0_0_20px_rgba(255,255,255,0.8)]",
                    feedback.rank === "EXCELLENT"
                      ? "text-yellow-400 scale-125"
                      : feedback.rank === "GREAT"
                      ? "text-cyan-400"
                      : "text-white"
                  )}
                >
                  {feedback.rank}!!
                </div>
                {/* 判定内容 (HIGH/LOW/JUST) を小さく添える */}
                <div className="text-xl font-bold text-white/80 mt-2 animate-pulse">
                  {feedback.msg}
                </div>
              </div>
            )}
          </div>
        )}

        {/* Controls */}
        <div className="w-full mt-8">
          <Keypad
            uiMode={config.uiMode}
            onInput={onAnswer}
            disabled={gameState.status !== "INPUT"}
          />
        </div>
      </div>

      {/* ★ Luxury Mode: Progression Lane (Footer Area) */}
      {!isRugged && (
        <div className="w-full relative z-10 pb-4">
          <ProgressionLane
            distance={gameState.distance}
            isMoving={feedback?.type === "CORRECT"}
          />
        </div>
      )}

      {/* Footer Controls */}
      <button
        onClick={onAbort}
        className="mb-4 flex items-center gap-2 text-xs font-bold opacity-30 hover:opacity-100 transition-opacity z-10"
      >
        <Home size={14} /> ABORT GAME
      </button>

      <style jsx global>{`
        @keyframes ping-once {
          0% {
            transform: scale(0.5);
            opacity: 0;
          }
          40% {
            transform: scale(1.1);
            opacity: 1;
          }
          100% {
            transform: scale(1);
            opacity: 0;
          }
        }
        .animate-ping-once {
          animation: ping-once 0.6s cubic-bezier(0, 0, 0.2, 1) forwards;
        }
      `}</style>
    </div>
  );
};
--- src/components/screens/HomeScreen.tsx ---
// src/components/screens/HomeScreen.tsx
import React from "react";
import {
  Settings,
  Zap,
  Volume2,
  VolumeX,
  Star,
  ArrowUp,
  ArrowDown,
} from "lucide-react";
import { cn } from "@/lib/utils";
import { GameConfig, Difficulty } from "@/types";

interface HomeScreenProps {
  config: GameConfig;
  setConfig: React.Dispatch<React.SetStateAction<GameConfig>>;
  highScore: number;
  onStart: () => void;
}

export const HomeScreen: React.FC<HomeScreenProps> = ({
  config,
  setConfig,
  highScore,
  onStart,
}) => {
  const isRugged = config.uiMode === "RUGGED";

  // 難易度リスト
  const difficulties: Difficulty[] = [
    "STARTER",
    "EASY",
    "NORMAL",
    "HARD",
    "EXTREME",
  ];

  return (
    <div
      className={cn(
        "min-h-screen w-full flex flex-col items-center justify-center p-4 sm:p-6 transition-colors duration-500 relative overflow-hidden",
        isRugged
          ? "bg-white text-black font-mono selection:bg-black selection:text-white"
          : "bg-[#0a0a16] text-white font-sans"
      )}
    >
      {/* 背景装飾（Luxuryモードのみ） */}
      {!isRugged && (
        <>
          <div className="absolute top-0 left-0 w-full h-full overflow-hidden pointer-events-none z-0">
            {/* Warning対応: w-[600px]->w-150, h-[600px]->h-150 */}
            <div className="absolute top-[-20%] left-[-10%] w-150 h-150 bg-cyan-600/20 rounded-full blur-[100px] sm:blur-[120px] mix-blend-screen animate-pulse" />
            <div className="absolute bottom-[-20%] right-[-10%] w-150 h-150 bg-purple-600/20 rounded-full blur-[100px] sm:blur-[120px] mix-blend-screen animate-pulse delay-1000" />
          </div>
        </>
      )}

      {/* Main Container: 幅制限を緩めて余裕を持たせる */}
      <div className="max-w-lg w-full space-y-8 relative z-10 flex flex-col items-center">
        {/* IMPACT TITLE AREA */}
        <div className="flex flex-col items-center justify-center py-8 sm:py-12 select-none w-full">
          {/* HIGH */}
          <div className="relative group">
            {/* 修正ポイント: px-4 py-2 を追加して bg-clip-text の描画エリアを広げる */}
            <h1
              className={cn(
                "px-4 py-2 text-5xl sm:text-7xl md:text-8xl font-black italic tracking-tighter leading-none transform -skew-x-6 transition-transform duration-300 group-hover:-translate-y-2",
                // Warning対応: bg-linear-to-t
                isRugged
                  ? "text-black"
                  : "text-transparent bg-clip-text bg-linear-to-t from-cyan-500 to-white drop-shadow-[0_0_15px_rgba(6,182,212,0.5)]"
              )}
            >
              HIGH
            </h1>
            {!isRugged && (
              <ArrowUp
                className="absolute -left-2 sm:-left-6 top-1/2 -translate-y-1/2 text-cyan-400 opacity-0 group-hover:opacity-100 transition-opacity duration-300"
                size={isRugged ? 24 : 40}
                strokeWidth={3}
              />
            )}
          </div>

          {/* SLASH & JUST */}
          {/* Warning対応: -my-1.25, sm:-my-2.5 */}
          <div className="flex items-center gap-2 sm:gap-4 -my-1.25 sm:-my-2.5 z-10">
            <span
              className={cn(
                "text-2xl sm:text-4xl font-black opacity-30",
                isRugged ? "text-black" : "text-white"
              )}
            >
              /
            </span>
            <div className="relative group">
              {/* 修正ポイント: px-4 py-2 を追加 */}
              <h1
                className={cn(
                  "px-4 py-2 text-7xl sm:text-8xl md:text-9xl font-black tracking-tighter leading-none relative",
                  isRugged
                    ? "text-black"
                    : "text-white drop-shadow-[0_0_25px_rgba(255,255,255,0.4)]"
                )}
              >
                JUST
              </h1>
              {/* JUSTの背面の光 */}
              {!isRugged && (
                <div className="absolute inset-0 bg-white/20 blur-xl rounded-full scale-125 opacity-0 group-hover:opacity-100 transition-opacity duration-200" />
              )}
            </div>
            <span
              className={cn(
                "text-2xl sm:text-4xl font-black opacity-30",
                isRugged ? "text-black" : "text-white"
              )}
            >
              /
            </span>
          </div>

          {/* LOW */}
          <div className="relative group">
            {/* 修正ポイント: px-4 py-2 を追加。これでWの右端切れも解消 */}
            <h1
              className={cn(
                "px-4 py-2 text-5xl sm:text-7xl md:text-8xl font-black italic tracking-tighter leading-none transform -skew-x-6 transition-transform duration-300 group-hover:translate-y-2",
                // Warning対応: bg-linear-to-b
                isRugged
                  ? "text-black"
                  : "text-transparent bg-clip-text bg-linear-to-b from-purple-400 to-purple-600 drop-shadow-[0_0_15px_rgba(168,85,247,0.5)]"
              )}
            >
              LOW
            </h1>
            {!isRugged && (
              <ArrowDown
                className="absolute -right-2 sm:-right-6 top-1/2 -translate-y-1/2 text-purple-400 opacity-0 group-hover:opacity-100 transition-opacity duration-300"
                size={isRugged ? 24 : 40}
                strokeWidth={3}
              />
            )}
          </div>

          <p
            className={cn(
              "mt-8 sm:mt-10 text-[10px] sm:text-xs font-bold tracking-[0.5em] uppercase opacity-70 text-center whitespace-nowrap",
              isRugged ? "text-gray-600" : "text-cyan-200/80"
            )}
          >
            Instant Reflex Game
          </p>
        </div>

        {/* Settings Grid */}
        <div
          className={cn(
            "grid grid-cols-2 gap-3 sm:gap-4 backdrop-blur-sm transition-all duration-300 w-full max-w-md",
            !isRugged &&
              "bg-white/5 border border-white/10 p-4 sm:p-6 rounded-3xl shadow-2xl"
          )}
        >
          {/* Difficulty */}
          <div className="col-span-2 space-y-2 sm:space-y-3">
            <div className="flex justify-between items-center px-1">
              <label className="text-[10px] font-bold tracking-widest opacity-60">
                DIFFICULTY
              </label>
              {config.difficulty === "STARTER" && (
                <span className="text-[10px] font-bold text-yellow-400 animate-pulse">
                  ★ RECOMMENDED
                </span>
              )}
            </div>
            <div className="flex flex-wrap gap-2">
              {difficulties.map((d) => (
                <button
                  key={d}
                  onClick={() =>
                    setConfig((prev) => ({ ...prev, difficulty: d }))
                  }
                  // Warning対応: active:translate-y-0.5
                  className={cn(
                    "flex-1 py-2 sm:py-3 text-[10px] sm:text-xs font-black transition-all uppercase whitespace-nowrap border-b-2 active:border-b-0 active:translate-y-0.5",
                    d === "STARTER" &&
                      config.difficulty !== d &&
                      "ring-1 ring-yellow-500/50 text-yellow-500 border-yellow-500/30",

                    config.difficulty === d
                      ? isRugged
                        ? "bg-black text-white border-transparent"
                        : d === "STARTER"
                        ? "bg-yellow-500 text-black border-yellow-700 shadow-[0_0_15px_rgba(234,179,8,0.4)]"
                        : "bg-cyan-600 text-white border-cyan-800 shadow-[0_0_15px_rgba(8,145,178,0.4)]"
                      : isRugged
                      ? "bg-gray-100 text-gray-400 border-gray-200"
                      : "bg-white/5 text-gray-400 border-white/5 hover:bg-white/10",
                    !isRugged && "rounded-lg"
                  )}
                >
                  {d === "STARTER" && (
                    <Star
                      size={10}
                      className="inline mr-1 -mt-0.5"
                      fill="currentColor"
                    />
                  )}
                  {d}
                </button>
              ))}
            </div>
          </div>

          {/* UI Toggle */}
          <button
            onClick={() =>
              setConfig((prev) => ({
                ...prev,
                uiMode: prev.uiMode === "RUGGED" ? "LUXURY" : "RUGGED",
              }))
            }
            className={cn(
              "col-span-1 flex items-center justify-center gap-2 py-3 text-xs font-bold transition-all",
              isRugged
                ? "border-2 border-gray-200 text-gray-400 hover:border-gray-400 hover:text-black"
                : "bg-white/5 text-white/70 hover:bg-white/10 hover:text-white rounded-lg"
            )}
          >
            {isRugged ? <Settings size={14} /> : <Zap size={14} />}
            {config.uiMode}
          </button>

          {/* Sound Toggle */}
          <button
            onClick={() =>
              setConfig((prev) => ({
                ...prev,
                isSoundEnabled: !prev.isSoundEnabled,
              }))
            }
            className={cn(
              "col-span-1 flex items-center justify-center gap-2 py-3 text-xs font-bold transition-all",
              isRugged
                ? "border-2 border-gray-200 text-gray-400 hover:border-gray-400 hover:text-black"
                : "bg-white/5 text-white/70 hover:bg-white/10 hover:text-white rounded-lg"
            )}
          >
            {config.isSoundEnabled ? (
              <Volume2 size={14} />
            ) : (
              <VolumeX size={14} />
            )}
            SOUND
          </button>
        </div>

        {/* Start Button */}
        <button
          onClick={onStart}
          // Warning対応: bg-linear-to-r
          className={cn(
            "w-full max-w-md py-5 sm:py-6 text-xl sm:text-2xl font-black tracking-[0.2em] transition-all hover:scale-[1.02] active:scale-95 shadow-xl relative overflow-hidden group",
            isRugged
              ? "bg-black text-white border-b-8 border-gray-800 active:border-b-0 active:translate-y-2"
              : "bg-linear-to-r from-cyan-500 via-blue-500 to-purple-600 text-white rounded-2xl shadow-cyan-500/20"
          )}
        >
          <span className="relative z-10 flex items-center justify-center gap-4">
            START GAME
          </span>
          {/* Button Shine Effect */}
          {!isRugged && (
            // Warning対応: bg-linear-to-r
            <div className="absolute inset-0 -translate-x-full group-hover:translate-x-full transition-transform duration-700 bg-linear-to-r from-transparent via-white/20 to-transparent skew-x-12" />
          )}
        </button>

        <div className="text-center">
          <span
            className={cn(
              "text-[10px] font-bold px-3 py-1 rounded-full",
              isRugged
                ? "bg-gray-100 text-gray-400"
                : "bg-white/5 text-white/30"
            )}
          >
            HIGH SCORE: {highScore}
          </span>
        </div>
      </div>
    </div>
  );
};
--- src/components/ui/ProgressionLane.tsx ---
// src/components/ui/ProgressionLane.tsx
import React from "react";
import { cn } from "@/lib/utils";
import { Footprints, MapPin } from "lucide-react";

interface ProgressionLaneProps {
  distance: number; // 累積距離
  isMoving: boolean; // 正解直後かどうか
}

export const ProgressionLane: React.FC<ProgressionLaneProps> = ({
  distance,
  isMoving,
}) => {
  // 簡易的な無限スクロール演出
  // 距離に応じて背景位置をずらす
  const bgPos = -(distance * 2) % 1000;

  return (
    <div className="w-full h-16 relative overflow-hidden bg-black/40 border-t border-white/10 backdrop-blur-sm mt-4">
      {/* 流れる背景（地面のグリッドラインなど） */}
      <div
        className="absolute inset-0 opacity-20"
        style={{
          backgroundImage: `linear-gradient(90deg, transparent 95%, #00ffff 100%)`,
          backgroundSize: "50px 100%",
          transform: `translateX(${bgPos}px)`,
          transition: "transform 0.5s linear",
        }}
      />

      {/* プレイヤーキャラクター */}
      <div className="absolute left-8 bottom-4 text-cyan-400 filter drop-shadow-[0_0_8px_rgba(6,182,212,0.8)]">
        <div
          className={cn(
            "transition-transform duration-300",
            isMoving ? "animate-bounce" : ""
          )}
        >
          {/* シンプルな歩行アイコン */}
          <Footprints size={24} className="transform rotate-90" />
        </div>
      </div>

      {/* 距離表示 */}
      <div className="absolute right-4 bottom-4 font-mono text-xs text-white/50 flex items-center gap-1">
        <MapPin size={12} />
        {distance}m
      </div>

      {/* エフェクト粒子（簡易版） */}
      {isMoving && (
        <div className="absolute left-12 bottom-4 w-20 h-full bg-linear-to-r from-cyan-500/0 via-cyan-500/20 to-cyan-500/0 blur-md transform skew-x-12" />
      )}
    </div>
  );
};
--- src/components/ui/Keypad.tsx ---
// src/components/ui/Keypad.tsx
import React, { useEffect } from "react";
import { cn } from "@/lib/utils";
import { UIMode, AnswerType } from "@/types";
import { ArrowUp, ArrowDown, Target } from "lucide-react";

interface KeypadProps {
  onInput: (type: AnswerType) => void;
  disabled: boolean;
  uiMode: UIMode;
}

export const Keypad: React.FC<KeypadProps> = ({
  onInput,
  disabled,
  uiMode,
}) => {
  const isRugged = uiMode === "RUGGED";

  // キーボードショートカット対応
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (disabled) return;
      if (e.key === "ArrowUp") onInput("HIGH");
      if (e.key === "ArrowDown") onInput("LOW");
      if (e.key === "ArrowRight" || e.key === "Enter" || e.key === " ")
        onInput("JUST");
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [disabled, onInput]);

  const btnBase = isRugged
    ? "bg-gray-200 text-black border-4 border-gray-400 active:translate-y-1 active:border-b-0"
    : "backdrop-blur-md shadow-lg active:scale-95 transition-all";

  const highLowStyle = isRugged
    ? "hover:bg-gray-300"
    : "bg-white/10 border border-white/20 text-white hover:bg-white/20";

  const justStyle = isRugged
    ? "bg-black text-white border-black hover:bg-gray-800"
    : "bg-cyan-500/80 text-white border border-cyan-400 shadow-cyan-500/50 hover:bg-cyan-500";

  return (
    <div className="w-full max-w-sm mx-auto mt-6 flex gap-4 h-48">
      {/* 左側: HIGH / LOW */}
      <div className="flex-1 flex flex-col gap-4">
        <button
          disabled={disabled}
          onClick={() => onInput("HIGH")}
          className={cn(
            "flex-1 rounded-2xl flex flex-col items-center justify-center text-xl font-black tracking-widest gap-1",
            btnBase,
            highLowStyle
          )}
        >
          <ArrowUp size={32} />
          HIGH
        </button>
        <button
          disabled={disabled}
          onClick={() => onInput("LOW")}
          className={cn(
            "flex-1 rounded-2xl flex flex-col items-center justify-center text-xl font-black tracking-widest gap-1",
            btnBase,
            highLowStyle
          )}
        >
          <ArrowDown size={32} />
          LOW
        </button>
      </div>

      {/* 右側: JUST */}
      <button
        disabled={disabled}
        onClick={() => onInput("JUST")}
        className={cn(
          "flex-1 rounded-2xl flex flex-col items-center justify-center text-3xl font-black tracking-widest gap-2",
          btnBase,
          justStyle
        )}
      >
        <Target size={48} />
        JUST
      </button>
    </div>
  );
};
--- src/components/ui/NumberPanel.tsx ---
// src/components/ui/NumberPanel.tsx
import React from "react";
import { cn } from "@/lib/utils";
import { UIMode, GameStatus } from "@/types";

interface NumberPanelProps {
  formula: string;
  value: number;
  status: GameStatus;
  uiMode: UIMode;
}

export const NumberPanel: React.FC<NumberPanelProps> = ({
  formula,
  value,
  status,
  uiMode,
}) => {
  const isRugged = uiMode === "RUGGED";
  const isFlash = status === "FLASH";
  const isInput = status === "INPUT";

  return (
    <div
      className={cn(
        "flex flex-col items-center justify-center w-full h-48 transition-all relative",
        isRugged
          ? "border-4 border-black bg-white"
          : "bg-white/10 backdrop-blur-xl border border-white/20 rounded-3xl shadow-2xl"
      )}
    >
      {/* FLASH Phase: 計算式を一瞬表示 */}
      <div
        className={cn(
          "absolute inset-0 flex items-center justify-center text-5xl sm:text-6xl font-black tracking-tighter transition-opacity duration-100",
          isFlash
            ? "opacity-100 scale-100"
            : "opacity-0 scale-95 pointer-events-none"
        )}
      >
        {formula} = ?
      </div>

      {/* INPUT Phase: 判定対象の数字を表示 */}
      <div
        className={cn(
          "absolute inset-0 flex items-center justify-center text-7xl sm:text-8xl font-black tracking-tighter transition-all duration-100",
          isInput
            ? isRugged
              ? "text-black"
              : "text-white scale-110 drop-shadow-[0_0_15px_rgba(255,255,255,0.5)]"
            : "opacity-0 scale-150"
        )}
      >
        {value}
      </div>

      {/* 待機中の表示 */}
      {!isFlash && !isInput && (
        <div className="animate-pulse opacity-50 font-mono">WAITING...</div>
      )}
    </div>
  );
};
--- src/app/page.tsx ---
// src/app/page.tsx
"use client";

import React, { useState, useEffect } from "react";
import { GameConfig } from "@/types";
import { useGameEngine } from "@/hooks/useGameEngine";
import { HomeScreen } from "@/components/screens/HomeScreen";
import { GameScreen } from "@/components/screens/GameScreen";
import { ResultScreen } from "@/components/screens/ResultScreen";

export default function Page() {
  // 設定の初期値
  const [config, setConfig] = useState<GameConfig>({
    difficulty: "NORMAL",
    uiMode: "RUGGED",
    isSoundEnabled: true,
  });

  // ゲームエンジンの呼び出し
  const {
    gameState,
    feedback,
    initGame,
    startGame,
    exitGame,
    handleAnswer,
    setDifficulty,
  } = useGameEngine(config.isSoundEnabled, config.uiMode);

  // 難易度設定の同期
  useEffect(() => {
    setDifficulty(config.difficulty);
  }, [config.difficulty, setDifficulty]);

  // 1. ホーム画面 (IDLE状態)
  if (gameState.status === "IDLE") {
    return (
      <HomeScreen
        config={config}
        setConfig={setConfig}
        highScore={gameState.highScore}
        onStart={() => initGame(config.difficulty)}
      />
    );
  }

  // 2. リザルト画面 (GAMEOVER状態)
  if (gameState.status === "GAMEOVER") {
    return (
      <ResultScreen
        gameState={gameState}
        uiMode={config.uiMode}
        onRetry={() => initGame(config.difficulty)}
        onHome={exitGame}
      />
    );
  }

  // 3. ゲーム画面 (プレイ中)
  return (
    <GameScreen
      config={config}
      gameState={gameState}
      feedback={feedback}
      onAnswer={handleAnswer}
      onAbort={exitGame}
      onStartGame={startGame}
    />
  );
}
--- src/app/manifest.ts ---
--- src/app/layout.tsx ---
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
--- src/app/globals.css ---
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
--- src/lib/gameLogic.ts ---
// src/lib/gameLogic.ts
import { Difficulty, AnswerType } from '@/types';

interface Problem {
  formula: string;
  answer: number;
  display: number;
  type: AnswerType;
}

// 難易度ごとの設定
const SETTINGS = {
  STARTER: {
    min: 10, max: 30,
    terms: 2,
    diffRange: [10, 20],
    justRate: 0.4
  },
  EASY: {
    min: 10, max: 50,
    terms: 2,
    diffRange: [10, 20],
    justRate: 0.4
  },
  NORMAL: {
    min: 20, max: 90,
    terms: 2,
    diffRange: [5, 15],
    justRate: 0.3
  },
  HARD: {
    min: 100, max: 500,
    terms: 2,
    diffRange: [2, 10],
    justRate: 0.2
  },
  EXTREME: {
    min: 100, max: 999,
    terms: 3,
    diffRange: [1, 5],
    justRate: 0.15
  }
};

const randomInt = (min: number, max: number) => 
  Math.floor(Math.random() * (max - min + 1)) + min;

export const generateProblem = (difficulty: Difficulty): Problem => {
  const setting = SETTINGS[difficulty];
  const nums: number[] = [];
  
  for (let i = 0; i < setting.terms; i++) {
    nums.push(randomInt(setting.min, setting.max));
  }
  
  const answer = nums.reduce((a, b) => a + b, 0);
  const formula = nums.join(' + ');

  const rand = Math.random();
  let type: AnswerType;
  
  if (rand < setting.justRate) {
    type = 'JUST';
  } else {
    type = Math.random() < 0.5 ? 'HIGH' : 'LOW';
  }

  let display = answer;

  // ★ ここを修正：主語を「表示数字」にする
  if (type !== 'JUST') {
    const diff = randomInt(setting.diffRange[0], setting.diffRange[1]);
    
    if (type === 'HIGH') {
      // ユーザーが「HIGH」と答えるべき = 表示されている数字の方が「高い」
      display = answer + diff; 
    } else {
      // ユーザーが「LOW」と答えるべき = 表示されている数字の方が「低い」
      display = answer - diff; 
    }
  }

  return { formula, answer, display, type };
};--- src/lib/utils.ts ---
// src/lib/utils.ts
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

// クラス名の結合ユーティリティ
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// 漢数字・全角数字・ひらがな読みを半角数字に変換するパーサー（今回は未使用だがエラー防止のため残す）
export const parseVoiceInput = (text: string): number | 'PASS' | null => {
  if (!text) return null;
  let str = text.trim();

  if (/パス|スキップ|次|next|skip/gi.test(str)) {
    return 'PASS';
  }

  const kanjiMap: { [key: string]: number } = {
    '〇':0, '一':1, '二':2, '三':3, '四':4, '五':5, '六':6, '七':7, '八':8, '九':9,
    '０':0, '１':1, '２':2, '３':3, '４':4, '５':5, '６':6, '７':7, '８':8, '９':9
  };
  
  str = str.split('').map(char => kanjiMap[char] !== undefined ? kanjiMap[char] : char).join('');
  str = str.replace(/[^0-9]/g, "");

  if (str === "") return null;
  
  const num = parseInt(str, 10);
  return isNaN(num) ? null : num;
};--- src/lib/storage.ts ---
// src/lib/storage.ts

const HIGHSCORE_KEY = 'hjl_highscore'; // キー名を変更してBetweenと競合しないようにしました

export const getHighScore = (): number => {
  if (typeof window === 'undefined') return 0;
  const saved = localStorage.getItem(HIGHSCORE_KEY);
  return saved ? parseInt(saved, 10) : 0;
};

export const saveHighScore = (score: number): void => {
  if (typeof window === 'undefined') return;
  localStorage.setItem(HIGHSCORE_KEY, score.toString());
};--- src/hooks/useVoiceInput.ts ---
--- src/hooks/useGameEngine.ts ---
// src/hooks/useGameEngine.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { GameState, Difficulty, FeedbackState, AnswerType, UIMode, FeedbackRank } from '@/types';
import { generateProblem } from '@/lib/gameLogic';
import { getHighScore, saveHighScore } from '@/lib/storage';

const GAUGE_MAX = 100;

const TIME_SETTINGS = {
  STARTER: { flash: 1800, limit: 4000, damage: 5,  heal: 15 },
  EASY:    { flash: 1200, limit: 3000, damage: 8,  heal: 10 },
  NORMAL:  { flash: 800,  limit: 2000, damage: 12, heal: 8 },
  HARD:    { flash: 500,  limit: 1500, damage: 18, heal: 6 },
  EXTREME: { flash: 300,  limit: 1200, damage: 25, heal: 5 },
};

export const useGameEngine = (soundEnabled: boolean, uiMode: UIMode) => {
  const [gameState, setGameState] = useState<GameState>({
    status: 'IDLE',
    score: 0,
    highScore: 0,
    combo: 0,
    maxCombo: 0,
    clearGauge: 60,
    difficulty: 'NORMAL',
    currentFormula: "",
    targetValue: 0,
    displayValue: 0,
    correctType: 'JUST',
    questionCount: 0,
    distance: 0, // ★ 初期値
  });
  
  const [feedback, setFeedback] = useState<FeedbackState | null>(null);
  const inputStartTimeRef = useRef<number>(0); // ★ 回答開始時間を記録

  useEffect(() => {
    setGameState(prev => ({ ...prev, highScore: getHighScore() }));
  }, []);

  useEffect(() => {
    if (gameState.score > gameState.highScore) {
      saveHighScore(gameState.score);
      setGameState(prev => ({ ...prev, highScore: prev.score }));
    }
  }, [gameState.score, gameState.highScore]);

  useEffect(() => {
    if (gameState.status !== 'INPUT') return;

    const settings = TIME_SETTINGS[gameState.difficulty];
    inputStartTimeRef.current = Date.now(); // ★ タイマー開始

    const timeoutId = setTimeout(() => {
      handleAnswer('MISS_TIMEOUT');
    }, settings.limit);

    return () => clearTimeout(timeoutId);
  }, [gameState.status, gameState.currentFormula, gameState.difficulty]);

  const nextProblem = useCallback((diff: Difficulty) => {
    const prob = generateProblem(diff);
    const settings = TIME_SETTINGS[diff];

    setGameState(prev => {
        const isFirstStarter = diff === 'STARTER' && prev.questionCount === 0;
        const flashDuration = isFirstStarter ? settings.flash + 500 : settings.flash;

        setTimeout(() => {
            setGameState(curr => {
                if (curr.status !== 'FLASH') return curr;
                return { ...curr, status: 'INPUT' };
            });
        }, flashDuration);

        return {
            ...prev,
            status: 'FLASH',
            currentFormula: prob.formula,
            targetValue: prob.answer,
            displayValue: prob.display,
            correctType: prob.type,
            difficulty: diff,
            questionCount: prev.questionCount + 1
        };
    });
  }, []);

  const initGame = useCallback((diff: Difficulty) => {
    setGameState(prev => ({
      ...prev,
      status: 'COUNTDOWN',
      score: 0,
      combo: 0,
      clearGauge: 60,
      difficulty: diff,
      questionCount: 0,
      distance: 0,
    }));
    setFeedback(null);
  }, []);

  const startGame = useCallback(() => {
    nextProblem(gameState.difficulty);
  }, [gameState.difficulty, nextProblem]);

  const exitGame = useCallback(() => {
    setGameState(prev => ({ ...prev, status: 'IDLE' }));
  }, []);

  const handleAnswer = useCallback((playerAns: AnswerType | 'MISS_TIMEOUT') => {
    if (gameState.status !== 'INPUT' && playerAns !== 'MISS_TIMEOUT') return;

    const settings = TIME_SETTINGS[gameState.difficulty];
    const isCorrect = playerAns === gameState.correctType;
    const now = Date.now();
    const elapsed = now - inputStartTimeRef.current;
    
    // ★ ランク判定ロジック
    // 残り時間が 60%以上ならExcellent, 30%以上ならGreat
    const remainingRatio = Math.max(0, 1 - (elapsed / settings.limit));
    let rank: FeedbackRank = 'GOOD';
    if (remainingRatio > 0.6) rank = 'EXCELLENT';
    else if (remainingRatio > 0.3) rank = 'GREAT';

    if (isCorrect) {
      setFeedback({ type: 'CORRECT', rank, msg: gameState.correctType });
      
      setGameState(prev => {
        const newGauge = Math.min(GAUGE_MAX, prev.clearGauge + settings.heal);
        const newCombo = prev.combo + 1;
        // ★ 距離加算 (Luxury用): コンボが繋がるほど加速する演出も可能だが、まずは一定距離
        const moveDistance = 10 + Math.min(prev.combo, 10); 
        
        return {
          ...prev,
          score: prev.score + 100 + (prev.combo * 10),
          combo: newCombo,
          maxCombo: Math.max(prev.maxCombo, newCombo),
          clearGauge: newGauge,
          distance: prev.distance + moveDistance // 進む
        };
      });

      // @ts-ignore
      setTimeout(() => {
        setFeedback(null);
        nextProblem(gameState.difficulty);
      }, 200);

    } else {
      setFeedback({ type: playerAns === 'MISS_TIMEOUT' ? 'TIME_UP' : 'MISS', msg: 'MISS' });
      
      setGameState(prev => {
        const damage = playerAns === 'MISS_TIMEOUT' ? settings.damage + 5 : settings.damage;
        const newGauge = prev.clearGauge - damage;
        
        if (newGauge <= 0) {
          return { ...prev, status: 'GAMEOVER', clearGauge: 0, combo: 0 };
        }
        return { ...prev, combo: 0, clearGauge: newGauge };
        // ミス時は距離を進めない（立ち止まる）
      });

      // @ts-ignore
      if (gameState.clearGauge > 0) {
        setTimeout(() => {
            setFeedback(null);
            nextProblem(gameState.difficulty);
        }, 500);
      }
    }
  }, [gameState.status, gameState.correctType, gameState.difficulty, gameState.clearGauge, nextProblem]);

  const setDifficulty = useCallback((diff: Difficulty) => {
    setGameState(prev => ({ ...prev, difficulty: diff }));
  }, []);

  return {
    gameState,
    feedback,
    initGame,
    startGame,
    exitGame,
    handleAnswer,
    setDifficulty
  };
};--- src/hooks/useSmartVoiceJudge.ts ---
--- src/hooks/useSound.ts ---
// src/hooks/useSound.ts
import { useCallback, useRef, useEffect } from 'react';
import { FeedbackRank } from '@/types';

export const useSound = (enabled: boolean = true) => {
  const audioContextRef = useRef<AudioContext | null>(null);

  useEffect(() => {
    if (typeof window !== 'undefined') {
      const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
      if (AudioContext) {
        audioContextRef.current = new AudioContext();
      }
    }
    return () => {
      if (audioContextRef.current) {
        audioContextRef.current.close();
      }
    };
  }, []);

  const playTone = useCallback((freq: number, type: OscillatorType, duration: number, vol: number = 0.1) => {
    if (!enabled || !audioContextRef.current) return;
    const ctx = audioContextRef.current;
    if (ctx.state === 'suspended') ctx.resume();

    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = type;
    osc.frequency.setValueAtTime(freq, ctx.currentTime);
    
    gain.gain.setValueAtTime(vol, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start();
    osc.stop(ctx.currentTime + duration);
  }, [enabled]);

  // ★ ランク別の正解音
  const playRankSound = useCallback((rank: FeedbackRank) => {
    if (!enabled || !audioContextRef.current) return;
    const ctx = audioContextRef.current;
    if (ctx.state === 'suspended') ctx.resume();
    
    const t = ctx.currentTime;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc.connect(gain);
    gain.connect(ctx.destination);

    if (rank === 'EXCELLENT') {
      // ズキューン！ (低音から高音へ突き抜ける + 重低音)
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(200, t);
      osc.frequency.exponentialRampToValueAtTime(800, t + 0.1);
      gain.gain.setValueAtTime(0.3, t);
      gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
      
      // ベース音追加
      const bass = ctx.createOscillator();
      const bassGain = ctx.createGain();
      bass.type = 'sine';
      bass.frequency.setValueAtTime(100, t);
      bass.frequency.linearRampToValueAtTime(50, t + 0.3);
      bassGain.gain.setValueAtTime(0.5, t);
      bassGain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
      bass.connect(bassGain);
      bassGain.connect(ctx.destination);
      bass.start();
      bass.stop(t + 0.3);

      osc.start();
      osc.stop(t + 0.4);

    } else if (rank === 'GREAT') {
      // パシッ！ (キレの良い高音)
      osc.type = 'square';
      osc.frequency.setValueAtTime(600, t);
      osc.frequency.exponentialRampToValueAtTime(1200, t + 0.1);
      gain.gain.setValueAtTime(0.15, t);
      gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
      osc.start();
      osc.stop(t + 0.2);

    } else {
      // ポン (軽い音)
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800, t);
      gain.gain.setValueAtTime(0.1, t);
      gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
      osc.start();
      osc.stop(t + 0.1);
    }
  }, [enabled]);

  // 旧互換用
  const playCorrect = useCallback(() => playRankSound('GOOD'), [playRankSound]);
  const playPass = useCallback(() => playTone(300, 'triangle', 0.2, 0.2), [playTone]);
  const playCount = useCallback(() => playTone(800, 'sine', 0.1, 0.2), [playTone]);
  const playGo = useCallback(() => playTone(1600, 'square', 0.4, 0.2), [playTone]);

  return { playCorrect, playRankSound, playPass, playCount, playGo };
};--- src/types/index.ts ---
// src/types/index.ts

export type Difficulty = 'STARTER' | 'EASY' | 'NORMAL' | 'HARD' | 'EXTREME';
export type UIMode = 'RUGGED' | 'LUXURY';
export type GameStatus = 'IDLE' | 'COUNTDOWN' | 'FLASH' | 'INPUT' | 'RESULT' | 'GAMEOVER';
export type AnswerType = 'HIGH' | 'JUST' | 'LOW';
export type FeedbackRank = 'EXCELLENT' | 'GREAT' | 'GOOD'; // ★ 新規追加

export interface GameConfig {
  difficulty: Difficulty;
  uiMode: UIMode;
  isSoundEnabled: boolean;
}

export interface GameState {
  status: GameStatus;
  score: number;
  highScore: number;
  combo: number;
  maxCombo: number;
  clearGauge: number;
  difficulty: Difficulty;
  
  currentFormula: string;
  targetValue: number;
  displayValue: number;
  correctType: AnswerType;
  
  questionCount: number;
  
  // ★ 進行演出用（Luxury専用）
  distance: number; // 進んだ距離 (m)
}

export interface FeedbackState {
  type: 'CORRECT' | 'MISS' | 'TIME_UP';
  rank?: FeedbackRank; // ★ ランク情報を追加
  msg: string;
}